<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="styles/style.css">
<title>OpenFAM: A library for programming Fabric-Attached Memory</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
	<header>
		<h1>OpenFAM Reference Implementation</h1>
	</header>
	<section>
		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="release_notes.html">Release Notes</a></li>
				<li><a href="limitations.html">Design Choices</a></li>
				<li><a href="errors.html">Exceptions and Error Codes</a></li>
				<li><a href="services.html">Services</a></li>
				<li><a href="config_files.html">Configuration Files</a></li>
			</ul>
			<hr>
			Initialization and Finalization
			<ul>
				<li><a href="fam_initialize.html">fam_initialize</a></li>
				<li><a href="fam_finalize.html">fam_finalize</a></li>
				<li><a href="fam_abort.html">fam_abort</a></li>
			</ul>
			<hr>
			Options &amp; Query
			<ul>
				<li><a href="fam_list_options.html">fam_list_options</a></li>
				<li><a href="fam_get_option.html">fam_get_option</a></li>
				<li><a href="fam_lookup.html">fam_lookup</a></li>
				<li><a href="fam_stat.html">fam_stat</a></li>
			</ul>
			<hr>
			Memory Allocation
			<ul>
				<li><a href="fam_create_region.html">fam_create_region</a></li>
				<li><a href="fam_destroy_region.html">fam_destroy_region</a></li>
				<li><a href="fam_resize_region.html">fam_resize_region</a></li>
				<li><a href="fam_allocate.html">fam_allocate</a></li>
				<li><a href="fam_deallocate.html">fam_deallocate</a></li>
				<li><a href="fam_change_permissions.html">fam_change_permissions</a></li>
				<li><a href="fam_close.html">fam_close</a></li>
			</ul>
			<hr>
			Memory Map
			<ul>
				<li><a href="fam_map.html">fam_map</a></li>
				<li><a href="fam_unmap.html">fam_unmap</a></li>
			</ul>
			<hr>
			Data Path Operations
			<ul>
				<li><a href="fam_get.html">fam_get</a></li>
				<li><a href="fam_put.html">fam_put</a></li>
				<li><a href="fam_gather.html">fam_gather</a></li>
				<li><a href="fam_scatter.html">fam_scatter</a></li>
				<li><a href="fam_copy.html">fam_copy</a></li>
				<li><a href="fam_copy_wait.html">fam_copy_wait</a></li>
                                <li><a href="fam_backup.html">fam_backup</a></li>
                                <li><a href="fam_backup_wait.html">fam_backup_wait</a></li>
                                <li><a href="fam_restore.html">fam_restore</a></li>
                                <li><a href="fam_restore_wait.html">fam_restore_wait</a></li>
                                <li><a href="fam_delete_backup.html">fam_delete_backup</a></li>
                                <li><a href="fam_delete_backup_wait.html">fam_delete_backup_wait</a></li>

			</ul>
			<hr>
			Atomics
			<ul>
				<li><a href="fam_set.html">fam_set</a></li>
				<li><a href="fam_add.html">fam_add</a></li>
				<li><a href="fam_subtract.html">fam_subtract</a></li>
				<li><a href="fam_min.html">fam_min</a></li>
				<li><a href="fam_max.html">fam_max</a></li>
				<li><a href="fam_and.html">fam_and</a></li>
				<li><a href="fam_or.html">fam_or</a></li>
				<li><a href="fam_xor.html">fam_xor</a></li>
				<li><a href="fam_fetch_TYPE.html">fam_fetch_TYPE</a></li>
				<li><a href="fam_swap.html">fam_swap</a></li>
				<li><a href="fam_compare_swap.html">fam_compare_swap</a></li>
				<li><a href="fam_fetch_add.html">fam_fetch_add</a></li>
				<li><a href="fam_fetch_subtract.html">fam_fetch_subtract</a></li>
				<li><a href="fam_fetch_min.html">fam_fetch_min</a></li>
				<li><a href="fam_fetch_and.html">fam_fetch_and</a></li>
				<li><a href="fam_fetch_max.html">fam_fetch_max</a></li>
				<li><a href="fam_fetch_or.html">fam_fetch_or</a></li>
				<li><a href="fam_fetch_xor.html">fam_fetch_xor</a></li>
			</ul>
			<hr>
			Ordering
			<ul>
				<li><a href="fam_barrier_all.html">fam_barrier_all</a></li>
				<li><a href="fam_fence.html">fam_fence</a></li>
				<li><a href="fam_quiet.html">fam_quiet</a></li>
                                <li><a href="fam_progress.html">fam_progress</a></li>
                                <li><a href="fam_context_open.html">fam_context_open</a></li>
                                <li><a href="fam_context_close.html">fam_context_close</a></li>
			</ul>
			<hr>
		</nav>
		<article>
			<h1 class="code">openfam::fam::fam_stat</h1>
	<p>Get the size, permissions and name of a region or data item.</p>
	<h2>Synopsis</h2>
	<p class="code">void fam_stat(Fam_Descriptor *descriptor, Fam_Stat *famInfo);</p>
	<p class="code">void fam_stat(Fam_Region_Descriptor *descriptor, Fam_Stat *famInfo);</p>
	<h2>Description</h2>
	<p>These methods return the size, permissions and name associated with the data item or region descriptor.

	</p>
	<h2>Input Arguments</h2>
	<table>
		<tbody>
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td class="code">descriptor</td><td>Descriptor associated with the region or the data item.</td></tr>
			<tr><td class="code">famInfo</td><td>A pointer to the structure where the information is copied.</td></tr>
		</tbody>
	</table>
	<p>fam_stat() takes a pointer to the <code>Fam_Stat</code> structure as input to copy
	 the information associated with region or data item descriptor. </p>
	<pre>
typedef struct {
    uint64_t size;
    mode_t perm;
    uint32_t uid;
    uint32_t gid;
    char *name;    
    Fam_Region_Attributes region_attributes;
    int num_memservers;
    int interleaveSize;
    int *memory_servers;

} Fam_Stat;
	</pre>
		<table>
		<tbody>
			<tr><th>Name</th><th>Description</th><th>Default Value</th></tr>
			<tr>
				<td class="code">size</td><td>Size of the region or data item in bytes</td>
				<td>none</td>
			</tr>
			<tr><td class="code">perm</td><td>permissions associated with the region or data item</td><td>none</td></tr>
			<tr><td class="code">uid</td><td>uid associated with the region or data item</td><td>none</td></tr>
			<tr><td class="code">gid</td><td>gid associated with the region or data item</td><td>none</td></tr>
			<tr><td class="code">name</td><td>Name of the region or data item.</td>
				<td>none</td>
			</tr>
			<tr><td class="code">region_attributes</td><td>Region-specific attributes like redundancy level, MemoryType, InterleaveDisabled/Enabled .</td>
				<td>0</td>
			</tr>
			<tr><td class="code">num_memservers</td><td>Number of memory servers used for a region or data item.</td>
				<td>none</td>
			</tr>
			<tr><td class="code">interleaveSize</td><td>data item interleaving size used for a given region.</td>
				<td>none</td>
			</tr>
			<tr><td class="code">memory_servers</td><td>List of memory servers used for a given data item allocation. The list is ordered such that data item offset will be obtained as a multiple of list_element_index and interleaveSize. If  the data item goes beyond available memory servers, the allocation is done again from the beginning of list. In that case data item offset calculation on any memory server can be obtained as a multiple of (list_element_index * intereleaveSize) % num_memservers, added with (num_memservers * interleaveSize), each time we rollback to the beginning of list. </td>
				<td>none</td>
			</tr>
		</tbody>
	</table>
	<h2>Return Values</h2>
	<p>None. Throws <code>Fam_Exception</code> on error.</p>
	<h2>Fam Error Numbers</h2>
	<table>
	<tbody>
	<tr><th>Error</th><th>Description</th></tr>
	<tr><td class="code">FAM_ERR_INVALID</td><td>API called with incorrect parameters.</td></tr>
	<tr><td class="code">FAM_ERR_NOPERM</td><td>Caller does not have access rights.</td></tr>
	<tr><td class="code">FAM_ERR_NOTFOUND</td><td>Item or region name was not found by the metadata service.</td></tr>
	<tr><td class="code">FAM_ERR_RPC</td><td>Communication error from grpc layer.</td></tr>
	<tr><td class="code">FAM_ERR_RPC_CLIENT_NOTFOUND</td><td>RPC service not available.</td></tr>
	<tr><td class="code">FAM_ERR_METADATA</td><td>Metadata service error.</td></tr>
</tbody>
	</table>
	
	<h2>Example</h2>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fam/fam.h&gt;
#include &lt;fam/fam_exception.h&gt;
using namespace std;
using namespace openfam;

int main(void) {
	fam *myFam = new fam();
	
	// ... initialization code here
	
	try {
		// get a region descriptor from the metadata service
		Fam_Region_Descriptor *region = myFam-&gt;fam_lookup_region("myRegion");
		
		// allocate space for Fam_Stat structure.
		Fam_Stat *info = (Fam_Stat *)calloc(1, sizeof(Fam_Stat));
		myFam-&gt;fam_stat(region, info);
		printf("Region_size: %lu\n", info-&gt;size);
		
		// Get a descriptor (created by another PE) via the metadata service
		Fam_Descriptor *arrayDescriptor = myFam-&gt;fam_lookup("myArray", "myOtherRegion");
		
		// Get data item info
		myFam-&gt;fam_stat(arrayDescriptor, info);
		printf("array_size: %lu\n", info-&gt;size);
		
	} catch (Fam_Exception &amp;e) {
		printf("Fam API failed: %d: %s\n", e.fam_error(), e.fam_error_msg());
	}
		
	// ... continuation code here
}
</pre>
		</article>
	</section>
	<footer>
		<p>Copyright 2021-23, Hewlett Packard Enterprise Development Co, LLP</p>
	</footer>
</body>
</html>
