<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="styles/style.css">
<title>OpenFAM: A library for programming Fabric-Attached Memory</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
	<header>
		<h1>OpenFAM Reference Implementation</h1>
	</header>
	<section>
		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="limitations.html">Design Choices</a></li>
				<li><a href="errors.html">Exceptions and Error Codes</a></li>
				<li><a href="services.html">Services</a></li>
				<li><a href="config_files.html">Configuration Files</a></li>
			</ul>
			<hr>
			Initialization and Finalization
			<ul>
				<li><a href="fam_initialize.html">fam_initialize</a></li>
				<li><a href="fam_finalize.html">fam_finalize</a></li>
				<li><a href="fam_abort.html">fam_abort</a></li>
			</ul>
			<hr>
			Options &amp; Query
			<ul>
				<li><a href="fam_list_options.html">fam_list_options</a></li>
				<li><a href="fam_get_option.html">fam_get_option</a></li>
				<li><a href="fam_lookup.html">fam_lookup</a></li>
				<li><a href="fam_stat.html">fam_stat</a></li>
			</ul>
			<hr>
			Memory Allocation
			<ul>
				<li><a href="fam_create_region.html">fam_create_region</a></li>
				<li><a href="fam_destroy_region.html">fam_destroy_region</a></li>
				<li><a href="fam_resize_region.html">fam_resize_region</a></li>
				<li><a href="fam_allocate.html">fam_allocate</a></li>
				<li><a href="fam_deallocate.html">fam_deallocate</a></li>
				<li><a href="fam_change_permissions.html">fam_change_permissions</a></li>
			</ul>
			<hr>
			Memory Map
			<ul>
				<li><a href="fam_map.html">fam_map</a></li>
				<li><a href="fam_unmap.html">fam_unmap</a></li>
			</ul>
			<hr>
			Data Path Operations
			<ul>
				<li><a href="fam_get.html">fam_get</a></li>
				<li><a href="fam_put.html">fam_put</a></li>
				<li><a href="fam_gather.html">fam_gather</a></li>
				<li><a href="fam_scatter.html">fam_scatter</a></li>
				<li><a href="fam_copy.html">fam_copy</a></li>
				<li><a href="fam_copy_wait.html">fam_copy_wait</a></li>
			</ul>
			<hr>
			Atomics
			<ul>
				<li><a href="fam_set.html">fam_set</a></li>
				<li><a href="fam_add.html">fam_add</a></li>
				<li><a href="fam_subtract.html">fam_subtract</a></li>
				<li><a href="fam_min.html">fam_min</a></li>
				<li><a href="fam_max.html">fam_max</a></li>
				<li><a href="fam_and.html">fam_and</a></li>
				<li><a href="fam_or.html">fam_or</a></li>
				<li><a href="fam_xor.html">fam_xor</a></li>
				<li><a href="fam_fetch_TYPE.html">fam_fetch_TYPE</a></li>
				<li><a href="fam_swap.html">fam_swap</a></li>
				<li><a href="fam_compare_swap.html">fam_compare_swap</a></li>
				<li><a href="fam_fetch_add.html">fam_fetch_add</a></li>
				<li><a href="fam_fetch_subtract.html">fam_fetch_subtract</a></li>
				<li><a href="fam_fetch_min.html">fam_fetch_min</a></li>
				<li><a href="fam_fetch_and.html">fam_fetch_and</a></li>
				<li><a href="fam_fetch_max.html">fam_fetch_max</a></li>
				<li><a href="fam_fetch_or.html">fam_fetch_or</a></li>
				<li><a href="fam_fetch_xor.html">fam_fetch_xor</a></li>
			</ul>
			<hr>
			Ordering
			<ul>
				<li><a href="fam_barrier_all.html">fam_barrier_all</a></li>
				<li><a href="fam_fence.html">fam_fence</a></li>
				<li><a href="fam_quiet.html">fam_quiet</a></li>
			</ul>
			<hr>
		</nav>
		<article>
			<h1 class="code">openfam::fam::fam_gather</h1>
	<p>Copy disjoint elements of a data item from FAM to local memory.</p>
	<h2>Synopsis</h2>
	<p class="code">void fam_gather_blocking(void *local, Fam_Descriptor *descriptor,
		uint64_t nElements, uint64_t firstElement, uint64_t stride, uint64_t
		elementSize);</p>
	<p class="code">void fam_gather_blocking(void *local, Fam_Descriptor *descriptor,
		uint64_t nElements, uint64_t *elementIndex, uint64_t elementSize);</p>
	<p class="code">void fam_gather_nonblocking(void *local, Fam_Descriptor
		*descriptor, uint64_t nElements, uint64_t firstElement, uint64_t
		stride, uint64_t elementSize);</p>
	<p class="code">void fam_gather_nonblocking(void *local, Fam_Descriptor
		*descriptor, uint64_t nElements, uint64_t *elementIndex, uint64_t
		elementSize);</p>
	<h2>Description</h2>
	<p>Copy elements of a data item from FAM to local memory based on a constant or indexed stride.</p>
	<h2>Input Arguments</h2>
	<table>
		<tbody>
			<tr>
				<th>
					Name
				</th>
				<th>
					Description
				</th>
			</tr>
			<tr>
				<td class="code">
					local
				</td>
				<td>
					Pointer to appropriately sized area of local memory.
				</td>
			</tr>
			<tr>
				<td class="code">
					descriptor
				</td>
				<td>
					Descriptor associated with the data item in FAM.
				</td>
			</tr>
			<tr>
				<td class="code">
					nElements
				</td>
				<td>
					Number of elements to get.
				</td>
			</tr>
			<tr>
				<td class="code">
					firstElement
				</td>
				<td>
					Index (in FAM) of the first element within the data item to
						get.
				</td>
			</tr>
			<tr>
				<td class="code">
					elementIndex
				</td>
				<td>
					An array containing element indexes.
				</td>
			</tr>
			<tr>
				<td class="code">
					stride
				</td>
				<td>
					Stride to use when getting elements.
				</td>
			</tr>
			<tr>
				<td class="code">
					elementSize
				</td>
				<td>
					Size of each element to gather.
				</td>
			</tr>
		</tbody>
	</table>
	<h2>Return Values</h2>
	<p>These calls do not return a value on success. At return, the memory pointed to by
		local contains a copy of the data elements from FAM for the blocking
		calls. For non-blocking calls, local memory is not guaranteed to
		contain data until successful completion of a subsequent fam_quiet()
		call. Both non-blocking and blocking call throws Fam_Exception on
		error.</p>
	<h2>Fam Error Numbers</h2>
	<table>
	<tbody>
	<tr><th>Error</th><th>Description</th></tr>
	<tr><td class="code">FAM_ERR_INVALID</td><td>API called with incorrect parameters.</td></tr>
	<tr><td class="code">FAM_ERR_NOPERM</td><td>Caller does not have access rights.</td></tr>
	<tr><td class="code">FAM_ERR_LIBFABRIC</td><td>Libfabric error occurred.</td></tr>
	<tr><td class="code">FAM_ERR_NOTFOUND</td><td>Item not found in the region.</td></tr>
	<tr><td class="code">FAM_ERR_RPC</td><td>Communication error from grpc layer.</td></tr>
	<tr><td class="code">FAM_ERR_RPC_CLIENT_NOTFOUND</td><td>RPC service not available.</td></tr>
	<tr><td class="code">FAM_ERR_METADATA</td><td>Metadata service error.</td></tr>
	<tr><td class="code">FAM_ERR_MEMORY</td><td>Memory service error.</td></tr>
	<tr><td class="code">FAM_ERR_RESOURCE</td><td>Resource not available.</td></tr>
	<tr><td class="code">FAM_ERR_TIMEOUT</td><td>Number of libfabric retry count reached.</td></tr>
	</tbody>
	</table>
	<h2>Notes</h2>
	<p>The local memory pointer must point to an area of memory
		sufficient to accommodate the incoming data. Insufficient allocation
		of local memory may cause segmentation violations or corrupted data in
		local memory. This API assumes that the data item contains uniformly
		sized elements (e.g, a large array).&nbsp; Currently, the API gathers
		elements from within a single data item.</p>
	<h2>Example</h2>
<pre>
#include &lt;string.h>
#include &lt;fam/fam.h>
#include &lt;fam/fam_exception.h>
using namespace std;
using namespace openfam;

int main(void) {
	fam *myFam = new fam();
	
	// ... Initialization code here

	try {
		Fam_Descriptor *descriptor = myFam->fam_lookup("myItem", "myRegion");
	
		// allocate a 25-element integer array in local memory
		int *local = (int *) malloc(25 * sizeof(int));
	
		// gather all odd elements from myItem into local memory
		// first element is myItem[1]; collect 25 elements with stride 2
		myFam->fam_gather_blocking(local, descriptor, 25, (uint64_t) 1, 2, sizeof(int));
	
		// gather myItem[1,7,13,15,16]
		int *indexedLocal = (int *) malloc(5 * sizeof(int));
		uint64_t indexes[] = {1, 7, 13, 15, 16};
		myFam->fam_gather_blocking(indexedLocal, descriptor, 5, indexes, sizeof(int));
	
		// ... we now have the correct elements in local memory
	 } catch (Fam_Exception &amp;e) {
		printf("fam API failed: %d: %s\n", e.fam_error(), e.fam_error_msg());
	 }
	 // ... Finalization code follows
}
	
</pre>
		</article>
	</section>
	<footer>
		<p>Copyright 2021, Hewlett Packard Enterprise Development Co, LLP</p>
	</footer>
</body>
</html>
